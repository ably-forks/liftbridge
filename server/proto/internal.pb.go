// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server/proto/internal.proto

package proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Op int32

const (
	Op_CREATE_PARTITION Op = 0
	Op_SHRINK_ISR       Op = 1
	Op_REPORT_LEADER    Op = 2
	Op_CHANGE_LEADER    Op = 3
	Op_EXPAND_ISR       Op = 4
	Op_PAUSE_PARTITION  Op = 5
	Op_RESUME_PARTITION Op = 6
)

var Op_name = map[int32]string{
	0: "CREATE_PARTITION",
	1: "SHRINK_ISR",
	2: "REPORT_LEADER",
	3: "CHANGE_LEADER",
	4: "EXPAND_ISR",
	5: "PAUSE_PARTITION",
	6: "RESUME_PARTITION",
}

var Op_value = map[string]int32{
	"CREATE_PARTITION": 0,
	"SHRINK_ISR":       1,
	"REPORT_LEADER":    2,
	"CHANGE_LEADER":    3,
	"EXPAND_ISR":       4,
	"PAUSE_PARTITION":  5,
	"RESUME_PARTITION": 6,
}

func (x Op) String() string {
	return proto.EnumName(Op_name, int32(x))
}

func (Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{0}
}

type ServerState struct {
	ServerID             string   `protobuf:"bytes,1,opt,name=serverID,proto3" json:"serverID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerState) Reset()         { *m = ServerState{} }
func (m *ServerState) String() string { return proto.CompactTextString(m) }
func (*ServerState) ProtoMessage()    {}
func (*ServerState) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{0}
}
func (m *ServerState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerState.Merge(m, src)
}
func (m *ServerState) XXX_Size() int {
	return m.Size()
}
func (m *ServerState) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerState.DiscardUnknown(m)
}

var xxx_messageInfo_ServerState proto.InternalMessageInfo

func (m *ServerState) GetServerID() string {
	if m != nil {
		return m.ServerID
	}
	return ""
}

type RaftLog struct {
	Op                   Op                 `protobuf:"varint,1,opt,name=op,proto3,enum=proto.Op" json:"op,omitempty"`
	CreatePartitionOp    *CreatePartitionOp `protobuf:"bytes,2,opt,name=createPartitionOp,proto3" json:"createPartitionOp,omitempty"`
	ShrinkISROp          *ShrinkISROp       `protobuf:"bytes,3,opt,name=shrinkISROp,proto3" json:"shrinkISROp,omitempty"`
	ChangeLeaderOp       *ChangeLeaderOp    `protobuf:"bytes,4,opt,name=changeLeaderOp,proto3" json:"changeLeaderOp,omitempty"`
	ExpandISROp          *ExpandISROp       `protobuf:"bytes,5,opt,name=expandISROp,proto3" json:"expandISROp,omitempty"`
	PausePartitionOp     *PausePartitionOp  `protobuf:"bytes,6,opt,name=pausePartitionOp,proto3" json:"pausePartitionOp,omitempty"`
	ResumePartitionOp    *ResumePartitionOp `protobuf:"bytes,7,opt,name=resumePartitionOp,proto3" json:"resumePartitionOp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RaftLog) Reset()         { *m = RaftLog{} }
func (m *RaftLog) String() string { return proto.CompactTextString(m) }
func (*RaftLog) ProtoMessage()    {}
func (*RaftLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{1}
}
func (m *RaftLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftLog.Merge(m, src)
}
func (m *RaftLog) XXX_Size() int {
	return m.Size()
}
func (m *RaftLog) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftLog.DiscardUnknown(m)
}

var xxx_messageInfo_RaftLog proto.InternalMessageInfo

func (m *RaftLog) GetOp() Op {
	if m != nil {
		return m.Op
	}
	return Op_CREATE_PARTITION
}

func (m *RaftLog) GetCreatePartitionOp() *CreatePartitionOp {
	if m != nil {
		return m.CreatePartitionOp
	}
	return nil
}

func (m *RaftLog) GetShrinkISROp() *ShrinkISROp {
	if m != nil {
		return m.ShrinkISROp
	}
	return nil
}

func (m *RaftLog) GetChangeLeaderOp() *ChangeLeaderOp {
	if m != nil {
		return m.ChangeLeaderOp
	}
	return nil
}

func (m *RaftLog) GetExpandISROp() *ExpandISROp {
	if m != nil {
		return m.ExpandISROp
	}
	return nil
}

func (m *RaftLog) GetPausePartitionOp() *PausePartitionOp {
	if m != nil {
		return m.PausePartitionOp
	}
	return nil
}

func (m *RaftLog) GetResumePartitionOp() *ResumePartitionOp {
	if m != nil {
		return m.ResumePartitionOp
	}
	return nil
}

type CreatePartitionOp struct {
	Partition            *Partition `protobuf:"bytes,1,opt,name=partition,proto3" json:"partition,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CreatePartitionOp) Reset()         { *m = CreatePartitionOp{} }
func (m *CreatePartitionOp) String() string { return proto.CompactTextString(m) }
func (*CreatePartitionOp) ProtoMessage()    {}
func (*CreatePartitionOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{2}
}
func (m *CreatePartitionOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreatePartitionOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreatePartitionOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreatePartitionOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatePartitionOp.Merge(m, src)
}
func (m *CreatePartitionOp) XXX_Size() int {
	return m.Size()
}
func (m *CreatePartitionOp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatePartitionOp.DiscardUnknown(m)
}

var xxx_messageInfo_CreatePartitionOp proto.InternalMessageInfo

func (m *CreatePartitionOp) GetPartition() *Partition {
	if m != nil {
		return m.Partition
	}
	return nil
}

type ShrinkISROp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ReplicaToRemove      string   `protobuf:"bytes,3,opt,name=replicaToRemove,proto3" json:"replicaToRemove,omitempty"`
	Leader               string   `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,5,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShrinkISROp) Reset()         { *m = ShrinkISROp{} }
func (m *ShrinkISROp) String() string { return proto.CompactTextString(m) }
func (*ShrinkISROp) ProtoMessage()    {}
func (*ShrinkISROp) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{3}
}
func (m *ShrinkISROp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShrinkISROp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShrinkISROp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShrinkISROp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShrinkISROp.Merge(m, src)
}
func (m *ShrinkISROp) XXX_Size() int {
	return m.Size()
}
func (m *ShrinkISROp) XXX_DiscardUnknown() {
	xxx_messageInfo_ShrinkISROp.DiscardUnknown(m)
}

var xxx_messageInfo_ShrinkISROp proto.InternalMessageInfo

func (m *ShrinkISROp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ShrinkISROp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ShrinkISROp) GetReplicaToRemove() string {
	if m != nil {
		return m.ReplicaToRemove
	}
	return ""
}

func (m *ShrinkISROp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ShrinkISROp) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type ExpandISROp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ReplicaToAdd         string   `protobuf:"bytes,3,opt,name=replicaToAdd,proto3" json:"replicaToAdd,omitempty"`
	Leader               string   `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,5,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExpandISROp) Reset()         { *m = ExpandISROp{} }
func (m *ExpandISROp) String() string { return proto.CompactTextString(m) }
func (*ExpandISROp) ProtoMessage()    {}
func (*ExpandISROp) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{4}
}
func (m *ExpandISROp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpandISROp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpandISROp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExpandISROp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpandISROp.Merge(m, src)
}
func (m *ExpandISROp) XXX_Size() int {
	return m.Size()
}
func (m *ExpandISROp) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpandISROp.DiscardUnknown(m)
}

var xxx_messageInfo_ExpandISROp proto.InternalMessageInfo

func (m *ExpandISROp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ExpandISROp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ExpandISROp) GetReplicaToAdd() string {
	if m != nil {
		return m.ReplicaToAdd
	}
	return ""
}

func (m *ExpandISROp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ExpandISROp) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type ReportLeaderOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Replica              string   `protobuf:"bytes,3,opt,name=replica,proto3" json:"replica,omitempty"`
	Leader               string   `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,5,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportLeaderOp) Reset()         { *m = ReportLeaderOp{} }
func (m *ReportLeaderOp) String() string { return proto.CompactTextString(m) }
func (*ReportLeaderOp) ProtoMessage()    {}
func (*ReportLeaderOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{5}
}
func (m *ReportLeaderOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportLeaderOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportLeaderOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportLeaderOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportLeaderOp.Merge(m, src)
}
func (m *ReportLeaderOp) XXX_Size() int {
	return m.Size()
}
func (m *ReportLeaderOp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportLeaderOp.DiscardUnknown(m)
}

var xxx_messageInfo_ReportLeaderOp proto.InternalMessageInfo

func (m *ReportLeaderOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ReportLeaderOp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ReportLeaderOp) GetReplica() string {
	if m != nil {
		return m.Replica
	}
	return ""
}

func (m *ReportLeaderOp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ReportLeaderOp) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type ChangeLeaderOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Leader               string   `protobuf:"bytes,3,opt,name=leader,proto3" json:"leader,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeLeaderOp) Reset()         { *m = ChangeLeaderOp{} }
func (m *ChangeLeaderOp) String() string { return proto.CompactTextString(m) }
func (*ChangeLeaderOp) ProtoMessage()    {}
func (*ChangeLeaderOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{6}
}
func (m *ChangeLeaderOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeLeaderOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeLeaderOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeLeaderOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeLeaderOp.Merge(m, src)
}
func (m *ChangeLeaderOp) XXX_Size() int {
	return m.Size()
}
func (m *ChangeLeaderOp) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeLeaderOp.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeLeaderOp proto.InternalMessageInfo

func (m *ChangeLeaderOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ChangeLeaderOp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ChangeLeaderOp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

type PausePartitionOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PausePartitionOp) Reset()         { *m = PausePartitionOp{} }
func (m *PausePartitionOp) String() string { return proto.CompactTextString(m) }
func (*PausePartitionOp) ProtoMessage()    {}
func (*PausePartitionOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{7}
}
func (m *PausePartitionOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PausePartitionOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PausePartitionOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PausePartitionOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PausePartitionOp.Merge(m, src)
}
func (m *PausePartitionOp) XXX_Size() int {
	return m.Size()
}
func (m *PausePartitionOp) XXX_DiscardUnknown() {
	xxx_messageInfo_PausePartitionOp.DiscardUnknown(m)
}

var xxx_messageInfo_PausePartitionOp proto.InternalMessageInfo

func (m *PausePartitionOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *PausePartitionOp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

type ResumePartitionOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResumePartitionOp) Reset()         { *m = ResumePartitionOp{} }
func (m *ResumePartitionOp) String() string { return proto.CompactTextString(m) }
func (*ResumePartitionOp) ProtoMessage()    {}
func (*ResumePartitionOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{8}
}
func (m *ResumePartitionOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResumePartitionOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResumePartitionOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResumePartitionOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResumePartitionOp.Merge(m, src)
}
func (m *ResumePartitionOp) XXX_Size() int {
	return m.Size()
}
func (m *ResumePartitionOp) XXX_DiscardUnknown() {
	xxx_messageInfo_ResumePartitionOp.DiscardUnknown(m)
}

var xxx_messageInfo_ResumePartitionOp proto.InternalMessageInfo

func (m *ResumePartitionOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ResumePartitionOp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

type Partition struct {
	Subject              string   `protobuf:"bytes,1,opt,name=subject,proto3" json:"subject,omitempty"`
	Stream               string   `protobuf:"bytes,2,opt,name=stream,proto3" json:"stream,omitempty"`
	Id                   int32    `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	Group                string   `protobuf:"bytes,4,opt,name=group,proto3" json:"group,omitempty"`
	ReplicationFactor    int32    `protobuf:"varint,5,opt,name=replicationFactor,proto3" json:"replicationFactor,omitempty"`
	Replicas             []string `protobuf:"bytes,6,rep,name=replicas,proto3" json:"replicas,omitempty"`
	Leader               string   `protobuf:"bytes,7,opt,name=leader,proto3" json:"leader,omitempty"`
	Isr                  []string `protobuf:"bytes,8,rep,name=isr,proto3" json:"isr,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,9,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	Epoch                uint64   `protobuf:"varint,10,opt,name=epoch,proto3" json:"epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Partition) Reset()         { *m = Partition{} }
func (m *Partition) String() string { return proto.CompactTextString(m) }
func (*Partition) ProtoMessage()    {}
func (*Partition) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{9}
}
func (m *Partition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Partition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Partition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Partition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Partition.Merge(m, src)
}
func (m *Partition) XXX_Size() int {
	return m.Size()
}
func (m *Partition) XXX_DiscardUnknown() {
	xxx_messageInfo_Partition.DiscardUnknown(m)
}

var xxx_messageInfo_Partition proto.InternalMessageInfo

func (m *Partition) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Partition) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *Partition) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Partition) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Partition) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *Partition) GetReplicas() []string {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *Partition) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *Partition) GetIsr() []string {
	if m != nil {
		return m.Isr
	}
	return nil
}

func (m *Partition) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

func (m *Partition) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

// RaftJoinRequest is a request to join a Raft group.
type RaftJoinRequest struct {
	NodeID               string   `protobuf:"bytes,1,opt,name=nodeID,proto3" json:"nodeID,omitempty"`
	NodeAddr             string   `protobuf:"bytes,2,opt,name=nodeAddr,proto3" json:"nodeAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftJoinRequest) Reset()         { *m = RaftJoinRequest{} }
func (m *RaftJoinRequest) String() string { return proto.CompactTextString(m) }
func (*RaftJoinRequest) ProtoMessage()    {}
func (*RaftJoinRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{10}
}
func (m *RaftJoinRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftJoinRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftJoinRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftJoinRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftJoinRequest.Merge(m, src)
}
func (m *RaftJoinRequest) XXX_Size() int {
	return m.Size()
}
func (m *RaftJoinRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftJoinRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RaftJoinRequest proto.InternalMessageInfo

func (m *RaftJoinRequest) GetNodeID() string {
	if m != nil {
		return m.NodeID
	}
	return ""
}

func (m *RaftJoinRequest) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

// RaftJoinResponse is a response to a RaftJoinRequest.
type RaftJoinResponse struct {
	Error                string   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftJoinResponse) Reset()         { *m = RaftJoinResponse{} }
func (m *RaftJoinResponse) String() string { return proto.CompactTextString(m) }
func (*RaftJoinResponse) ProtoMessage()    {}
func (*RaftJoinResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{11}
}
func (m *RaftJoinResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftJoinResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftJoinResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftJoinResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftJoinResponse.Merge(m, src)
}
func (m *RaftJoinResponse) XXX_Size() int {
	return m.Size()
}
func (m *RaftJoinResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftJoinResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RaftJoinResponse proto.InternalMessageInfo

func (m *RaftJoinResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type MetadataSnapshot struct {
	Partitions           []*Partition `protobuf:"bytes,1,rep,name=partitions,proto3" json:"partitions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MetadataSnapshot) Reset()         { *m = MetadataSnapshot{} }
func (m *MetadataSnapshot) String() string { return proto.CompactTextString(m) }
func (*MetadataSnapshot) ProtoMessage()    {}
func (*MetadataSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{12}
}
func (m *MetadataSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataSnapshot.Merge(m, src)
}
func (m *MetadataSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *MetadataSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataSnapshot proto.InternalMessageInfo

func (m *MetadataSnapshot) GetPartitions() []*Partition {
	if m != nil {
		return m.Partitions
	}
	return nil
}

type ReplicationRequest struct {
	ReplicaID            string   `protobuf:"bytes,1,opt,name=replicaID,proto3" json:"replicaID,omitempty"`
	Offset               int64    `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplicationRequest) Reset()         { *m = ReplicationRequest{} }
func (m *ReplicationRequest) String() string { return proto.CompactTextString(m) }
func (*ReplicationRequest) ProtoMessage()    {}
func (*ReplicationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{13}
}
func (m *ReplicationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicationRequest.Merge(m, src)
}
func (m *ReplicationRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReplicationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicationRequest proto.InternalMessageInfo

func (m *ReplicationRequest) GetReplicaID() string {
	if m != nil {
		return m.ReplicaID
	}
	return ""
}

func (m *ReplicationRequest) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type LeaderEpochOffsetRequest struct {
	LeaderEpoch          uint64   `protobuf:"varint,1,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaderEpochOffsetRequest) Reset()         { *m = LeaderEpochOffsetRequest{} }
func (m *LeaderEpochOffsetRequest) String() string { return proto.CompactTextString(m) }
func (*LeaderEpochOffsetRequest) ProtoMessage()    {}
func (*LeaderEpochOffsetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{14}
}
func (m *LeaderEpochOffsetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderEpochOffsetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderEpochOffsetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaderEpochOffsetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderEpochOffsetRequest.Merge(m, src)
}
func (m *LeaderEpochOffsetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaderEpochOffsetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderEpochOffsetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderEpochOffsetRequest proto.InternalMessageInfo

func (m *LeaderEpochOffsetRequest) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type LeaderEpochOffsetResponse struct {
	EndOffset            int64    `protobuf:"varint,1,opt,name=endOffset,proto3" json:"endOffset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaderEpochOffsetResponse) Reset()         { *m = LeaderEpochOffsetResponse{} }
func (m *LeaderEpochOffsetResponse) String() string { return proto.CompactTextString(m) }
func (*LeaderEpochOffsetResponse) ProtoMessage()    {}
func (*LeaderEpochOffsetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{15}
}
func (m *LeaderEpochOffsetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderEpochOffsetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderEpochOffsetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaderEpochOffsetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderEpochOffsetResponse.Merge(m, src)
}
func (m *LeaderEpochOffsetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaderEpochOffsetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderEpochOffsetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderEpochOffsetResponse proto.InternalMessageInfo

func (m *LeaderEpochOffsetResponse) GetEndOffset() int64 {
	if m != nil {
		return m.EndOffset
	}
	return 0
}

type PropagatedRequest struct {
	Op                   Op                 `protobuf:"varint,1,opt,name=op,proto3,enum=proto.Op" json:"op,omitempty"`
	CreatePartitionOp    *CreatePartitionOp `protobuf:"bytes,2,opt,name=createPartitionOp,proto3" json:"createPartitionOp,omitempty"`
	ShrinkISROp          *ShrinkISROp       `protobuf:"bytes,3,opt,name=shrinkISROp,proto3" json:"shrinkISROp,omitempty"`
	ReportLeaderOp       *ReportLeaderOp    `protobuf:"bytes,4,opt,name=reportLeaderOp,proto3" json:"reportLeaderOp,omitempty"`
	ExpandISROp          *ExpandISROp       `protobuf:"bytes,5,opt,name=expandISROp,proto3" json:"expandISROp,omitempty"`
	PausePartitionOp     *PausePartitionOp  `protobuf:"bytes,6,opt,name=pausePartitionOp,proto3" json:"pausePartitionOp,omitempty"`
	ResumePartitionOp    *ResumePartitionOp `protobuf:"bytes,7,opt,name=resumePartitionOp,proto3" json:"resumePartitionOp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *PropagatedRequest) Reset()         { *m = PropagatedRequest{} }
func (m *PropagatedRequest) String() string { return proto.CompactTextString(m) }
func (*PropagatedRequest) ProtoMessage()    {}
func (*PropagatedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{16}
}
func (m *PropagatedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropagatedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropagatedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropagatedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropagatedRequest.Merge(m, src)
}
func (m *PropagatedRequest) XXX_Size() int {
	return m.Size()
}
func (m *PropagatedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PropagatedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PropagatedRequest proto.InternalMessageInfo

func (m *PropagatedRequest) GetOp() Op {
	if m != nil {
		return m.Op
	}
	return Op_CREATE_PARTITION
}

func (m *PropagatedRequest) GetCreatePartitionOp() *CreatePartitionOp {
	if m != nil {
		return m.CreatePartitionOp
	}
	return nil
}

func (m *PropagatedRequest) GetShrinkISROp() *ShrinkISROp {
	if m != nil {
		return m.ShrinkISROp
	}
	return nil
}

func (m *PropagatedRequest) GetReportLeaderOp() *ReportLeaderOp {
	if m != nil {
		return m.ReportLeaderOp
	}
	return nil
}

func (m *PropagatedRequest) GetExpandISROp() *ExpandISROp {
	if m != nil {
		return m.ExpandISROp
	}
	return nil
}

func (m *PropagatedRequest) GetPausePartitionOp() *PausePartitionOp {
	if m != nil {
		return m.PausePartitionOp
	}
	return nil
}

func (m *PropagatedRequest) GetResumePartitionOp() *ResumePartitionOp {
	if m != nil {
		return m.ResumePartitionOp
	}
	return nil
}

type Error struct {
	Code                 uint32   `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{17}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type PropagatedResponse struct {
	Op                   Op       `protobuf:"varint,1,opt,name=op,proto3,enum=proto.Op" json:"op,omitempty"`
	Error                *Error   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PropagatedResponse) Reset()         { *m = PropagatedResponse{} }
func (m *PropagatedResponse) String() string { return proto.CompactTextString(m) }
func (*PropagatedResponse) ProtoMessage()    {}
func (*PropagatedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{18}
}
func (m *PropagatedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropagatedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropagatedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropagatedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropagatedResponse.Merge(m, src)
}
func (m *PropagatedResponse) XXX_Size() int {
	return m.Size()
}
func (m *PropagatedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PropagatedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PropagatedResponse proto.InternalMessageInfo

func (m *PropagatedResponse) GetOp() Op {
	if m != nil {
		return m.Op
	}
	return Op_CREATE_PARTITION
}

func (m *PropagatedResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ServerInfoRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerInfoRequest) Reset()         { *m = ServerInfoRequest{} }
func (m *ServerInfoRequest) String() string { return proto.CompactTextString(m) }
func (*ServerInfoRequest) ProtoMessage()    {}
func (*ServerInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{19}
}
func (m *ServerInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerInfoRequest.Merge(m, src)
}
func (m *ServerInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ServerInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerInfoRequest proto.InternalMessageInfo

func (m *ServerInfoRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ServerInfoResponse struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Host                 string   `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Port                 int32    `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerInfoResponse) Reset()         { *m = ServerInfoResponse{} }
func (m *ServerInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ServerInfoResponse) ProtoMessage()    {}
func (*ServerInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{20}
}
func (m *ServerInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerInfoResponse.Merge(m, src)
}
func (m *ServerInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ServerInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServerInfoResponse proto.InternalMessageInfo

func (m *ServerInfoResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ServerInfoResponse) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ServerInfoResponse) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type PartitionStatusRequest struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionStatusRequest) Reset()         { *m = PartitionStatusRequest{} }
func (m *PartitionStatusRequest) String() string { return proto.CompactTextString(m) }
func (*PartitionStatusRequest) ProtoMessage()    {}
func (*PartitionStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{21}
}
func (m *PartitionStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionStatusRequest.Merge(m, src)
}
func (m *PartitionStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *PartitionStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionStatusRequest proto.InternalMessageInfo

func (m *PartitionStatusRequest) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *PartitionStatusRequest) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

type PartitionStatusResponse struct {
	Exists               bool     `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
	IsLeader             bool     `protobuf:"varint,2,opt,name=isLeader,proto3" json:"isLeader,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionStatusResponse) Reset()         { *m = PartitionStatusResponse{} }
func (m *PartitionStatusResponse) String() string { return proto.CompactTextString(m) }
func (*PartitionStatusResponse) ProtoMessage()    {}
func (*PartitionStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{22}
}
func (m *PartitionStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionStatusResponse.Merge(m, src)
}
func (m *PartitionStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *PartitionStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionStatusResponse proto.InternalMessageInfo

func (m *PartitionStatusResponse) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

func (m *PartitionStatusResponse) GetIsLeader() bool {
	if m != nil {
		return m.IsLeader
	}
	return false
}

type PartitionNotification struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionNotification) Reset()         { *m = PartitionNotification{} }
func (m *PartitionNotification) String() string { return proto.CompactTextString(m) }
func (*PartitionNotification) ProtoMessage()    {}
func (*PartitionNotification) Descriptor() ([]byte, []int) {
	return fileDescriptor_51680b730731ea79, []int{23}
}
func (m *PartitionNotification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionNotification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionNotification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionNotification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionNotification.Merge(m, src)
}
func (m *PartitionNotification) XXX_Size() int {
	return m.Size()
}
func (m *PartitionNotification) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionNotification.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionNotification proto.InternalMessageInfo

func (m *PartitionNotification) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *PartitionNotification) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func init() {
	proto.RegisterEnum("proto.Op", Op_name, Op_value)
	proto.RegisterType((*ServerState)(nil), "proto.ServerState")
	proto.RegisterType((*RaftLog)(nil), "proto.RaftLog")
	proto.RegisterType((*CreatePartitionOp)(nil), "proto.CreatePartitionOp")
	proto.RegisterType((*ShrinkISROp)(nil), "proto.ShrinkISROp")
	proto.RegisterType((*ExpandISROp)(nil), "proto.ExpandISROp")
	proto.RegisterType((*ReportLeaderOp)(nil), "proto.ReportLeaderOp")
	proto.RegisterType((*ChangeLeaderOp)(nil), "proto.ChangeLeaderOp")
	proto.RegisterType((*PausePartitionOp)(nil), "proto.PausePartitionOp")
	proto.RegisterType((*ResumePartitionOp)(nil), "proto.ResumePartitionOp")
	proto.RegisterType((*Partition)(nil), "proto.Partition")
	proto.RegisterType((*RaftJoinRequest)(nil), "proto.RaftJoinRequest")
	proto.RegisterType((*RaftJoinResponse)(nil), "proto.RaftJoinResponse")
	proto.RegisterType((*MetadataSnapshot)(nil), "proto.MetadataSnapshot")
	proto.RegisterType((*ReplicationRequest)(nil), "proto.ReplicationRequest")
	proto.RegisterType((*LeaderEpochOffsetRequest)(nil), "proto.LeaderEpochOffsetRequest")
	proto.RegisterType((*LeaderEpochOffsetResponse)(nil), "proto.LeaderEpochOffsetResponse")
	proto.RegisterType((*PropagatedRequest)(nil), "proto.PropagatedRequest")
	proto.RegisterType((*Error)(nil), "proto.Error")
	proto.RegisterType((*PropagatedResponse)(nil), "proto.PropagatedResponse")
	proto.RegisterType((*ServerInfoRequest)(nil), "proto.ServerInfoRequest")
	proto.RegisterType((*ServerInfoResponse)(nil), "proto.ServerInfoResponse")
	proto.RegisterType((*PartitionStatusRequest)(nil), "proto.PartitionStatusRequest")
	proto.RegisterType((*PartitionStatusResponse)(nil), "proto.PartitionStatusResponse")
	proto.RegisterType((*PartitionNotification)(nil), "proto.PartitionNotification")
}

func init() { proto.RegisterFile("server/proto/internal.proto", fileDescriptor_51680b730731ea79) }

var fileDescriptor_51680b730731ea79 = []byte{
	// 991 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0xaf, 0xed, 0x4d, 0x76, 0xf3, 0xd2, 0xa6, 0xce, 0xd0, 0x6e, 0x5d, 0x58, 0xad, 0xa2, 0xe1,
	0xb2, 0x20, 0xd8, 0xa2, 0x85, 0x0b, 0x12, 0x1c, 0x42, 0xd6, 0x65, 0x53, 0xb2, 0x49, 0x34, 0x4e,
	0x25, 0x4e, 0xac, 0xdc, 0x78, 0x92, 0x18, 0x76, 0x3d, 0x66, 0x66, 0x52, 0xf5, 0x3b, 0x70, 0xe0,
	0x8a, 0xb8, 0x21, 0x21, 0x71, 0xe3, 0x73, 0x70, 0xe4, 0x23, 0xa0, 0xe5, 0x8b, 0xa0, 0x19, 0x8f,
	0x1d, 0xdb, 0xa9, 0x38, 0xa4, 0x17, 0xc4, 0x29, 0xf3, 0xfe, 0xfd, 0xde, 0xcf, 0xef, 0xbd, 0x79,
	0x13, 0x78, 0x47, 0x50, 0xfe, 0x92, 0xf2, 0x27, 0x29, 0x67, 0x92, 0x3d, 0x89, 0x13, 0x49, 0x79,
	0x12, 0x5e, 0x9f, 0x6a, 0x11, 0x35, 0xf4, 0x0f, 0x7e, 0x0f, 0xda, 0x81, 0xf6, 0x0a, 0x64, 0x28,
	0x29, 0x7a, 0x1b, 0x0e, 0xb2, 0xa0, 0xe1, 0xb9, 0x67, 0xf5, 0xac, 0x93, 0x16, 0x29, 0x64, 0xfc,
	0xab, 0x03, 0xfb, 0x24, 0x5c, 0xc8, 0x11, 0x5b, 0xa2, 0xc7, 0x60, 0xb3, 0x54, 0x7b, 0x74, 0xce,
	0x5a, 0x19, 0xe2, 0xe9, 0x24, 0x25, 0x36, 0x4b, 0xd1, 0x53, 0xe8, 0xce, 0x39, 0x0d, 0x25, 0x9d,
	0x86, 0x5c, 0xc6, 0x32, 0x66, 0xc9, 0x24, 0xf5, 0xec, 0x9e, 0x75, 0xd2, 0x3e, 0xf3, 0x8c, 0xe7,
	0xa0, 0x6e, 0x27, 0xdb, 0x21, 0xe8, 0x13, 0x68, 0x8b, 0x15, 0x8f, 0x93, 0xef, 0x86, 0x01, 0x99,
	0xa4, 0x9e, 0xa3, 0x11, 0x90, 0x41, 0x08, 0x36, 0x16, 0x52, 0x76, 0x43, 0x9f, 0x43, 0x67, 0xbe,
	0x0a, 0x93, 0x25, 0x1d, 0xd1, 0x30, 0xa2, 0x7c, 0x92, 0x7a, 0x7b, 0x3a, 0xf0, 0x61, 0x9e, 0xba,
	0x62, 0x24, 0x35, 0x67, 0x95, 0x94, 0xbe, 0x4a, 0xc3, 0x24, 0xca, 0x92, 0x36, 0x2a, 0x49, 0xfd,
	0x8d, 0x85, 0x94, 0xdd, 0xd0, 0x00, 0xdc, 0x34, 0x5c, 0x8b, 0xca, 0x17, 0x37, 0x75, 0xe8, 0x23,
	0x13, 0x3a, 0xad, 0x99, 0xc9, 0x56, 0x80, 0xaa, 0x1b, 0xa7, 0x62, 0x7d, 0x53, 0x41, 0xd9, 0xaf,
	0xd4, 0x8d, 0xd4, 0xed, 0x64, 0x3b, 0x04, 0x0f, 0xa0, 0xbb, 0x55, 0x5f, 0x74, 0x0a, 0xad, 0x34,
	0x17, 0x75, 0xdb, 0xda, 0x67, 0x6e, 0x41, 0xcd, 0xe8, 0xc9, 0xc6, 0x05, 0xff, 0x66, 0x41, 0xbb,
	0x54, 0x63, 0x74, 0x08, 0x4d, 0x21, 0x39, 0x0d, 0x6f, 0xcc, 0x54, 0x18, 0x09, 0x1d, 0x95, 0x71,
	0x55, 0x93, 0x1b, 0x25, 0x14, 0x74, 0x02, 0xf7, 0x39, 0x4d, 0xaf, 0xe3, 0x79, 0x38, 0x63, 0x84,
	0xde, 0xb0, 0x97, 0x54, 0xb7, 0xb1, 0x45, 0xea, 0x6a, 0x85, 0x7f, 0xad, 0x7b, 0xa0, 0xdb, 0xd5,
	0x22, 0x46, 0x42, 0x3d, 0x68, 0x67, 0x27, 0x3f, 0x65, 0xf3, 0x95, 0xee, 0xc7, 0x1e, 0x29, 0xab,
	0xf0, 0x2f, 0x16, 0xb4, 0x4b, 0x8d, 0xd9, 0x91, 0x29, 0x86, 0xbb, 0x05, 0xa5, 0x7e, 0x14, 0x19,
	0x9a, 0x15, 0xdd, 0x1b, 0x70, 0xfc, 0xd9, 0x82, 0x0e, 0xa1, 0x29, 0xe3, 0xb2, 0x18, 0xb4, 0xdd,
	0x68, 0x7a, 0xb0, 0x6f, 0x28, 0x19, 0x86, 0xb9, 0xf8, 0x06, 0xe4, 0xbe, 0x81, 0x4e, 0xf5, 0x52,
	0xec, 0xc8, 0x6d, 0xc3, 0xc0, 0x29, 0x33, 0xc0, 0x17, 0xe0, 0xd6, 0xa7, 0x7f, 0xb7, 0x0c, 0x78,
	0x08, 0xdd, 0xad, 0x1b, 0xb0, 0x23, 0xd4, 0x8f, 0x36, 0xb4, 0xa6, 0xe5, 0xb2, 0x8a, 0xf5, 0x8b,
	0x6f, 0xe9, 0x5c, 0x1a, 0x90, 0x5c, 0x2c, 0xa1, 0xdb, 0x15, 0xf4, 0x0e, 0xd8, 0x71, 0x36, 0x25,
	0x0d, 0x62, 0xc7, 0x11, 0x7a, 0x00, 0x8d, 0x25, 0x67, 0xeb, 0xd4, 0x54, 0x3f, 0x13, 0xd0, 0x07,
	0xea, 0x4a, 0xeb, 0xfe, 0xa8, 0x34, 0x4f, 0xc3, 0xb9, 0x64, 0x5c, 0xb7, 0xa0, 0x41, 0xb6, 0x0d,
	0x6a, 0xf7, 0x1a, 0xa5, 0xf0, 0x9a, 0x3d, 0x47, 0xed, 0xde, 0x5c, 0x2e, 0x15, 0x77, 0xbf, 0xd2,
	0x5e, 0x17, 0x9c, 0x58, 0x70, 0xef, 0x40, 0xbb, 0xab, 0x63, 0xbd, 0xe1, 0xad, 0xad, 0x86, 0x2b,
	0xae, 0x54, 0xdb, 0x40, 0xdb, 0x32, 0x01, 0xfb, 0x70, 0x5f, 0x2d, 0xf7, 0x67, 0x2c, 0x4e, 0x08,
	0xfd, 0x7e, 0x4d, 0x85, 0xfe, 0xf8, 0x84, 0x45, 0xb4, 0x78, 0x0a, 0x8c, 0xa4, 0x88, 0xaa, 0x53,
	0x3f, 0x8a, 0xb8, 0x29, 0x4b, 0x21, 0xe3, 0x13, 0x70, 0x37, 0x30, 0x22, 0x65, 0x89, 0xa0, 0x3a,
	0x21, 0xe7, 0x8c, 0x1b, 0x98, 0x4c, 0xc0, 0xe7, 0xe0, 0x5e, 0x52, 0x19, 0x46, 0xa1, 0x0c, 0x83,
	0x24, 0x4c, 0xc5, 0x8a, 0x49, 0xf4, 0x11, 0x40, 0xd1, 0x23, 0xe1, 0x59, 0x3d, 0xe7, 0xb5, 0x7b,
	0xaa, 0xe4, 0x83, 0x9f, 0x01, 0x22, 0x9b, 0x4a, 0xe6, 0xcc, 0x8f, 0xa0, 0x65, 0x4a, 0x57, 0x90,
	0xdf, 0x28, 0xd4, 0x77, 0xb1, 0xc5, 0x42, 0x50, 0xa9, 0xd9, 0x3b, 0xc4, 0x48, 0xf8, 0x33, 0xf0,
	0x46, 0x9b, 0x3a, 0x4d, 0xb4, 0x32, 0x47, 0xac, 0x95, 0xd5, 0xda, 0xbe, 0x47, 0x9f, 0xc2, 0xe3,
	0xd7, 0x44, 0x9b, 0x12, 0x1c, 0x41, 0x8b, 0x26, 0x51, 0xa6, 0xd4, 0xc1, 0x0e, 0xd9, 0x28, 0xf0,
	0xef, 0x0e, 0x74, 0xa7, 0x9c, 0xa5, 0xe1, 0x32, 0x94, 0x34, 0xca, 0x53, 0xfe, 0x97, 0xdf, 0x58,
	0x5e, 0xd9, 0x66, 0xb5, 0x37, 0xb6, 0xba, 0xea, 0x48, 0xcd, 0xf9, 0xff, 0xf0, 0xc6, 0x7e, 0x08,
	0x0d, 0x5f, 0x0d, 0x31, 0x42, 0xb0, 0x37, 0x67, 0x11, 0xd5, 0x5d, 0xba, 0x47, 0xf4, 0x59, 0xdd,
	0xc9, 0x1b, 0xb1, 0x34, 0x37, 0x43, 0x1d, 0x71, 0x00, 0xa8, 0xdc, 0x5e, 0x33, 0x13, 0xff, 0xd2,
	0x5f, 0x9c, 0xdf, 0x98, 0xac, 0xa7, 0x77, 0xf3, 0xe2, 0x28, 0x5d, 0x7e, 0x7f, 0xde, 0x85, 0x6e,
	0xf6, 0xcf, 0x6d, 0x98, 0x2c, 0x58, 0x3e, 0x33, 0xd9, 0x5e, 0xca, 0x26, 0xde, 0x8e, 0x23, 0x3c,
	0x02, 0x54, 0x76, 0x32, 0x99, 0x6b, 0x5e, 0xea, 0x2b, 0x56, 0x4c, 0x48, 0x43, 0x59, 0x9f, 0x95,
	0x4e, 0x75, 0xcd, 0xec, 0x38, 0x7d, 0xc6, 0x63, 0x38, 0x2c, 0xaa, 0xa0, 0xfe, 0x2f, 0xae, 0x45,
	0x69, 0x55, 0xec, 0xb0, 0x85, 0x2f, 0xe1, 0xd1, 0x16, 0x9e, 0xa1, 0x78, 0x08, 0x4d, 0xfa, 0x2a,
	0x16, 0x52, 0x68, 0xc0, 0x03, 0x62, 0x24, 0xb5, 0x7b, 0x62, 0x91, 0x8d, 0x92, 0xc6, 0x3b, 0x20,
	0x85, 0x8c, 0x2f, 0xe1, 0x61, 0x01, 0x37, 0x66, 0x32, 0x5e, 0x98, 0xad, 0xb0, 0x1b, 0xbb, 0xf7,
	0x7f, 0xb0, 0xc0, 0x9e, 0xa4, 0xe8, 0x01, 0xb8, 0x03, 0xe2, 0xf7, 0x67, 0xfe, 0xd5, 0xb4, 0x4f,
	0x66, 0xc3, 0xd9, 0x70, 0x32, 0x76, 0xef, 0xa0, 0x0e, 0x40, 0x70, 0x41, 0x86, 0xe3, 0xaf, 0xae,
	0x86, 0x01, 0x71, 0x2d, 0xd4, 0x85, 0x7b, 0xc4, 0x9f, 0x4e, 0xc8, 0xec, 0x6a, 0xe4, 0xf7, 0xcf,
	0x7d, 0xe2, 0xda, 0x4a, 0x35, 0xb8, 0xe8, 0x8f, 0xbf, 0xf4, 0x73, 0x95, 0xa3, 0xa2, 0xfc, 0xaf,
	0xa7, 0xfd, 0xf1, 0xb9, 0x8e, 0xda, 0x43, 0x6f, 0xc1, 0xfd, 0x69, 0xff, 0x79, 0x50, 0x86, 0x6e,
	0xa8, 0x84, 0xc4, 0x0f, 0x9e, 0x5f, 0x96, 0xb5, 0xcd, 0x2f, 0xdc, 0x3f, 0x6e, 0x8f, 0xad, 0x3f,
	0x6f, 0x8f, 0xad, 0xbf, 0x6e, 0x8f, 0xad, 0x9f, 0xfe, 0x3e, 0xbe, 0xf3, 0xa2, 0xa9, 0x87, 0xe2,
	0xe3, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe3, 0x7d, 0x97, 0x2f, 0xe7, 0x0b, 0x00, 0x00,
}

func (m *ServerState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServerID) > 0 {
		i -= len(m.ServerID)
		copy(dAtA[i:], m.ServerID)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ServerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ResumePartitionOp != nil {
		{
			size, err := m.ResumePartitionOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PausePartitionOp != nil {
		{
			size, err := m.PausePartitionOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ExpandISROp != nil {
		{
			size, err := m.ExpandISROp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ChangeLeaderOp != nil {
		{
			size, err := m.ChangeLeaderOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ShrinkISROp != nil {
		{
			size, err := m.ShrinkISROp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CreatePartitionOp != nil {
		{
			size, err := m.CreatePartitionOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreatePartitionOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePartitionOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreatePartitionOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Partition != nil {
		{
			size, err := m.Partition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShrinkISROp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShrinkISROp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShrinkISROp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeaderEpoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ReplicaToRemove) > 0 {
		i -= len(m.ReplicaToRemove)
		copy(dAtA[i:], m.ReplicaToRemove)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ReplicaToRemove)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExpandISROp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpandISROp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExpandISROp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeaderEpoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ReplicaToAdd) > 0 {
		i -= len(m.ReplicaToAdd)
		copy(dAtA[i:], m.ReplicaToAdd)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ReplicaToAdd)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportLeaderOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportLeaderOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportLeaderOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeaderEpoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Replica) > 0 {
		i -= len(m.Replica)
		copy(dAtA[i:], m.Replica)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Replica)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangeLeaderOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeLeaderOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeLeaderOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PausePartitionOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PausePartitionOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PausePartitionOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResumePartitionOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResumePartitionOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResumePartitionOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Partition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Partition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Partition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Epoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x50
	}
	if m.LeaderEpoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Isr) > 0 {
		for iNdEx := len(m.Isr) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Isr[iNdEx])
			copy(dAtA[i:], m.Isr[iNdEx])
			i = encodeVarintInternal(dAtA, i, uint64(len(m.Isr[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Replicas[iNdEx])
			copy(dAtA[i:], m.Replicas[iNdEx])
			i = encodeVarintInternal(dAtA, i, uint64(len(m.Replicas[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x22
	}
	if m.Id != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftJoinRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftJoinRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftJoinRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NodeAddr) > 0 {
		i -= len(m.NodeAddr)
		copy(dAtA[i:], m.NodeAddr)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.NodeAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftJoinResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftJoinResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftJoinResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetadataSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInternal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplicationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Offset != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ReplicaID) > 0 {
		i -= len(m.ReplicaID)
		copy(dAtA[i:], m.ReplicaID)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ReplicaID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LeaderEpochOffsetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderEpochOffsetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaderEpochOffsetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeaderEpoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LeaderEpochOffsetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderEpochOffsetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaderEpochOffsetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndOffset != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.EndOffset))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PropagatedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropagatedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropagatedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ResumePartitionOp != nil {
		{
			size, err := m.ResumePartitionOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PausePartitionOp != nil {
		{
			size, err := m.PausePartitionOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ExpandISROp != nil {
		{
			size, err := m.ExpandISROp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ReportLeaderOp != nil {
		{
			size, err := m.ReportLeaderOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ShrinkISROp != nil {
		{
			size, err := m.ShrinkISROp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CreatePartitionOp != nil {
		{
			size, err := m.CreatePartitionOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PropagatedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropagatedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropagatedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServerInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServerInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsLeader {
		i--
		if m.IsLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Exists {
		i--
		if m.Exists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionNotification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionNotification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintInternal(dAtA []byte, offset int, v uint64) int {
	offset -= sovInternal(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ServerState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovInternal(uint64(m.Op))
	}
	if m.CreatePartitionOp != nil {
		l = m.CreatePartitionOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ShrinkISROp != nil {
		l = m.ShrinkISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ChangeLeaderOp != nil {
		l = m.ChangeLeaderOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ExpandISROp != nil {
		l = m.ExpandISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.PausePartitionOp != nil {
		l = m.PausePartitionOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ResumePartitionOp != nil {
		l = m.ResumePartitionOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreatePartitionOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Partition != nil {
		l = m.Partition.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShrinkISROp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.ReplicaToRemove)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExpandISROp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.ReplicaToAdd)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportLeaderOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.Replica)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeLeaderOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PausePartitionOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResumePartitionOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Partition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovInternal(uint64(m.Id))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovInternal(uint64(m.ReplicationFactor))
	}
	if len(m.Replicas) > 0 {
		for _, s := range m.Replicas {
			l = len(s)
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Isr) > 0 {
		for _, s := range m.Isr {
			l = len(s)
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.Epoch != 0 {
		n += 1 + sovInternal(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftJoinRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftJoinResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetadataSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplicationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReplicaID)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovInternal(uint64(m.Offset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeaderEpochOffsetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeaderEpochOffsetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndOffset != 0 {
		n += 1 + sovInternal(uint64(m.EndOffset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropagatedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovInternal(uint64(m.Op))
	}
	if m.CreatePartitionOp != nil {
		l = m.CreatePartitionOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ShrinkISROp != nil {
		l = m.ShrinkISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ReportLeaderOp != nil {
		l = m.ReportLeaderOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ExpandISROp != nil {
		l = m.ExpandISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.PausePartitionOp != nil {
		l = m.PausePartitionOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ResumePartitionOp != nil {
		l = m.ResumePartitionOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovInternal(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropagatedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovInternal(uint64(m.Op))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovInternal(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exists {
		n += 2
	}
	if m.IsLeader {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionNotification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovInternal(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInternal(x uint64) (n int) {
	return sovInternal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ServerState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatePartitionOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatePartitionOp == nil {
				m.CreatePartitionOp = &CreatePartitionOp{}
			}
			if err := m.CreatePartitionOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShrinkISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShrinkISROp == nil {
				m.ShrinkISROp = &ShrinkISROp{}
			}
			if err := m.ShrinkISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLeaderOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeLeaderOp == nil {
				m.ChangeLeaderOp = &ChangeLeaderOp{}
			}
			if err := m.ChangeLeaderOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpandISROp == nil {
				m.ExpandISROp = &ExpandISROp{}
			}
			if err := m.ExpandISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PausePartitionOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PausePartitionOp == nil {
				m.PausePartitionOp = &PausePartitionOp{}
			}
			if err := m.PausePartitionOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumePartitionOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumePartitionOp == nil {
				m.ResumePartitionOp = &ResumePartitionOp{}
			}
			if err := m.ResumePartitionOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePartitionOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePartitionOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePartitionOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Partition == nil {
				m.Partition = &Partition{}
			}
			if err := m.Partition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShrinkISROp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShrinkISROp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShrinkISROp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaToRemove = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpandISROp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpandISROp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpandISROp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaToAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaToAdd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportLeaderOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportLeaderOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportLeaderOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replica = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeLeaderOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeLeaderOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeLeaderOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PausePartitionOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PausePartitionOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PausePartitionOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResumePartitionOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResumePartitionOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResumePartitionOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Partition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Partition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Partition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Isr = append(m.Isr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftJoinRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftJoinRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftJoinRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftJoinResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftJoinResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftJoinResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &Partition{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderEpochOffsetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderEpochOffsetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderEpochOffsetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderEpochOffsetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderEpochOffsetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderEpochOffsetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOffset", wireType)
			}
			m.EndOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropagatedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropagatedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropagatedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatePartitionOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatePartitionOp == nil {
				m.CreatePartitionOp = &CreatePartitionOp{}
			}
			if err := m.CreatePartitionOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShrinkISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShrinkISROp == nil {
				m.ShrinkISROp = &ShrinkISROp{}
			}
			if err := m.ShrinkISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportLeaderOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportLeaderOp == nil {
				m.ReportLeaderOp = &ReportLeaderOp{}
			}
			if err := m.ReportLeaderOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpandISROp == nil {
				m.ExpandISROp = &ExpandISROp{}
			}
			if err := m.ExpandISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PausePartitionOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PausePartitionOp == nil {
				m.PausePartitionOp = &PausePartitionOp{}
			}
			if err := m.PausePartitionOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumePartitionOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumePartitionOp == nil {
				m.ResumePartitionOp = &ResumePartitionOp{}
			}
			if err := m.ResumePartitionOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropagatedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropagatedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropagatedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeader = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionNotification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionNotification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInternal(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInternal
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthInternal
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInternal(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthInternal
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInternal = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInternal   = fmt.Errorf("proto: integer overflow")
)
